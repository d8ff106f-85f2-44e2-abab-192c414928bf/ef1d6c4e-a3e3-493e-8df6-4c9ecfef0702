received email, reading

-- signed 2026-02-06T00:06:55Z


summary: have big mesh, make cross section.

critical question: can I assume mesh to have tetrahedral cells?

worst case is loose triangle soup

can't open google drive link

-- signed 2026-02-06T00:13:23Z


mesh format:
- ~300MB file text file, sections delineated by $<section name> and $End<section name>, has MeshFormat, Entities, Nodes, and Elements
- list entities, each line starts with index number followed by arbitrary arr of values
- list nodes, index number // [n]vec3 // four int attrs?
  - last entry of nodes (797606) all [n]vec3
- list elements, one line of four int attrs then [m][n]int

-- signed 2026-02-06T00:32:18Z


KEY IDEA: only dragging the plane needs to be fast.
This means that I can do all the sorting after entering the plane angle
freezing during this precomputation is not mentioned in the reqs

-- signed 2026-02-06T00:49:13Z


5M elements, 
if all tetrahedra (coordination number 4),
worst case 20M vec3s, 
best case 5M * 4 / 4 = 5M vec3s

if I load them all into GPU memory and do an indirect draw call,
how much gpu mem does it use? 

elements: 5M * [4]u32 index = 80MB
points: 5M * [3]f32 * 4 / 4  = 60MB

140 MB, doable even on laptops

-- signed 2026-02-06T01:13:12Z


game plan:
- precompute rotated coords and sort by Z' axis
- precompute 1D AABB of all tets, referencing index of sorted coord 
- sort a min list and max list, ref sorted index
- on drag:
  - sweep through sorted coord list, find critical index
  - sweep through min list until value of index is at thresh
  - sweep through max list until value of index is at thresh
  - choose the shorter of the min/max list, worst case is 50% culled
  - allocate, loop through the chosen list and push intersecting tets, worst case is all are intersectiong
  - worst case: 2.5M u32 comparisons, say it's 10 cycles then at 1GHz it's 40fps -- might need further binning
  - now we get a list of triangles cut by the plane.


Deliverable Intermediates
step 1: (native) impl just culling, profile wall time, print to file
step 2: (native) add line list, profile wall time, print to file
step 3: rendering stuff

-- signed 2026-02-06T02:42:50Z


Bedtime. Coded a little bit after dinner for rough estimate of sorting 5M f32s and swap.

Unoptimized around 5 sec, optimized around 2 sec.

-- signed 2026-02-06T07:30:00Z

Memory swap might be the bottleneck compared to coord transform.
Need to benchmark sort vs transform on SoA vs AoS

also consider if matmul-then-insert is faster

...Ok matmul 5M elems is negligible

-- signed 2026-02-06T23:00:07Z


Checkpoint: raw matmul and sorting is acceptable. Leave it at naive impl and focus on culling now.

I have sorted list of points.

Assume list of tets.

keep arrs parallel so it's easy to memcpy whe building lists for in-place sort

Loop thorugh 5M tets:
  - given four vertices, record the indicies of the one with min and max Z
  - build unsorted aabb list (include the tet index for easy memcpy next)
    | tet | min | max |
    |-----|-----|-----|
    |  0  | 253 | 728 |
    |  1  | 129 | 417 |
    |  2  | 653 | 123 |
  - build sorted min list and max list
    | min | tet |     | max | tet |
    |-----|-----|     |-----|-----|
    | 102 | 233 |     | 301 | 623 |
    | 103 | 629 |     | 301 | 125 |
    | 103 | 192 |     | 302 | 920 |
    | 104 | 456 |     | 303 | 128 |
  - on sweep time:
    - binary search through sorted points list to find critical index
    - binary search where to cut the min and max list respectively
    - iterate over the shorter of the min/max list
      - naive: immediately start cuting the triangles, at most three faces cut
      - SIMD: build triangle soup, insert only if indices cross the critical index

-- signed 2026-02-07T00:56:06Z

|            |            |            |                  |                 |          |          |          |
|            |            |            |                  |                 |          |          |          |
| original x | original y | original z | rank of original | index of sorted | x sorted | y sorted | z sorted |
|            |            |            |                  |                 |          |          |          |
|            |            |            |                  |                 |          |          |          |


|             |                    |           |                    |           |                    |
|             |                    |           |                    |           |                    |
| v0 v1 v2 v3 |                    | tet index | rank of max vertex | tet index | rank of min vertex |
|             |                    |           |                    |           |                    |
|             |                    |           |                    |           |                    |


checkpoint, close to early bedtime

pay attent to fencepost error for tets generation

-- signed 2026-02-07T05:20:25Z


woke 1pm

use normal colors in frag shader, calc in vert shader

first test wireframe perf with SDL_Render

start thinking about parser

still need to actually generate triangle list, should use GL map

need to keep copy of unrotated coords

-- signed 2026-02-07T23:20:21Z


triangle list and lookup logic working. 

now need to calc the cuts

-- signed 2026-02-08T00:51:06Z


vertex table
||       |       |       ||       |       |       |          ||         |        |        |        ||
||       |       |       ||       |       |       |          ||         |        |        |        ||
|| src x | src y | src z || rot x | rot y | rot z | rot rank || sort id | sort x | sort y | sort z ||
||       |       |       ||       |       |       |          ||         |        |        |        ||
||       |       |       ||       |       |       |          ||         |        |        |        ||

tets table
||             |     |     ||             |          ||             |          ||
||             |     |     ||             |          ||             |          ||
|| v0 v1 v2 v3 | min | max || min_sort id | min_sort || max_sort id | max_sort ||
||             |     |     ||             |          ||             |          ||
||             |     |     ||             |          ||             |          ||

-- signed 2026-02-08T00:59:30Z


segment computation working.

all that remains is rendering and loading

-- signed 2026-02-08T07:40:43Z







starting challenge part 2

parser: start with @embedfile() instead of dealing with io

may rewrite parser in js if can't figure out wasm io


nodes sparse table
||   owner  | <T> + *data ||
||----------|-------------||
||          |             ||
|| u2 + u30 |  u1 + u31   ||
||          |             ||

node<non-parametric> dense table
||  x  |  y  |  z  ||
||-----|-----|-----||
||     |     |     ||
|| f32 | f32 | f32 ||
||     |     |     ||

elements sparse table
||   owner  | <T> | *data ||
||----------|-----|-------||
||          |     |       ||
|| u2 + u30 | u32 |  u32  ||
||          |     |       ||

elem<tet> dense table
|| v0 v1 v2 v3 ||
||-------------||
||             ||
||   [4]u32    ||
||             ||
(points to dense index, not sparse index)


No backlink index in dense tables since we're not modifying after load

Parse steps:
1. load nodes, write coord in dense and record location in sparse
2. load tets, lookup sparse node table for dense location then record in sparse elem table

-- signed 2026-02-15T23:44:33Z


parse number of point, curve, surface, and volume entities

for number of points, skip, line_index++
for number of curves, skip, line_index++
for number of surfac, skip, line_index++
for number of volume:
    record aabb, add pending allocation

parse number of nodes, allocate node dense table (will be extra, since some are non-volume)
parse min/max node indices, allocate node sparse table
for nodes:
    skip if not belonging to volume entity
    skip if parametric
    record xyz in dense, record dense location in sparse at nodetag

parse number of elems, allocate elem dense table (extras for non-vol)
parse min/max elem indices, allocate elem sparse table
for elems:
    skip if not belonging to volume entity
    skip if not tetrahedron
    for nodetags, lookup sparse node table and write dense location to dense elem table, record written location

just for challenge, return dense elem table and dense node table and discard sparse tables

const TetSoup = struct {
    aabb: [4]f32,
    nodes: [3][]f32,
    elems: [][4]u32,
};

can do light parsing of elem/node count beforehand and return to js to allocate, then call wasm for loading node/elem.
this is early loding stage so no need to worry about wasm boundary latency

-- signed 2026-02-16T00:14:06Z




init:

    const geometry = new THREE.BufferGeometry();
    const pos_arr = new Float32Array(4 * tets_count);
    const pos_attr = new THREE.BufferAttribute( pos_arr, 3 );
    geometry.setAttribute('position', att_pos);
    geometry.setDrawRange(0, 0);
    const material = new THREE.LineBasicMaterial( { color: 0xffffff } );
    const segments = new THREE.LineSegments( geometry, material );




update:

    const geometry = segments.geometry;
    const pos_attr = geometry.getAttribute('position');
    const pos_arr = pos_attr.array;


    const cuts_count = wasm.calcuate_slice(pos_arr, slider.value);


    geometry.setDrawRange(0, cuts_count);
    pos_attr.clearUpdateRanges();
    pos_attr.addUpdateRange();
    pos_attr.needsUpdate();




-- signed 2026-02-16T00:56:23Z



implemented sparse set, next step is to actually loop through the file

take the sliced text

first line is always metadata, so just read until linebreak

initialize Node struct, allocate lut and data 

next line, tokenize by space, read last entry to find how many entries in a block
if skipping, skip by n*2 lines
if parsing, iterate by line to get index, then iterator for n linees to find the data

use std.mem.tokenizeAny to get iterator

-- signed 2026-02-16T04:07:55Z


completed and validated parser

-- signed 2026-02-16T07:13:39Z



shoehorned the parser main into sdl demo with hardcoded vert count to test perf

SDL extremely slow due to drawing sheer number of segments

disabling drawing the mesh and only the slider makes it blazing fast

around 300k cuts at max


looks sooooo trippy, I love it, esp how the void shows up near the center.


sleeping, fix it tmr, should take about an hour or two to reorganize code.

remaining time is react renderer. Validate render perf with webgpu renderer first

-- signed 2026-02-16T09:13:29Z



can't hand off array directly to wasm, instead export an output buffer and user BufferAttribute.copyArray(wasm_out)

-- signed 2026-02-16T21:39:17Z




r3f test shows that you can have a persistent buffer handed to threejs and just update it and mark .needsUpdate = true



if wasm module requests its own address space

zig build-exe wasm.zig -target wasm32-freestanding -fno-entry -rdynamic



if wasm module gets an address space handed to it:

zig build-exe wasm.zig -target wasm32-freestanding -fno-entry -rdynamic --import-memory


in either case, you need to kindly ask the wasm module which address ranges are safe to access from javascript.

-- signed 2026-02-17T04:52:43Z