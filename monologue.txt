received email, reading

-- signed 2026-02-06T00:06:55Z


summary: have big mesh, make cross section.

critical question: can I assume mesh to have tetrahedral cells?

worst case is loose triangle soup

can't open google drive link

-- signed 2026-02-06T00:13:23Z


mesh format:
- ~300MB file text file, sections delineated by $<section name> and $End<section name>, has MeshFormat, Entities, Nodes, and Elements
- list entities, each line starts with index number followed by arbitrary arr of values
- list nodes, index number // [n]vec3 // four int attrs?
  - last entry of nodes (797606) all [n]vec3
- list elements, one line of four int attrs then [m][n]int

-- signed 2026-02-06T00:32:18Z


KEY IDEA: only dragging the plane needs to be fast.
This means that I can do all the sorting after entering the plane angle
freezing during this precomputation is not mentioned in the reqs

-- signed 2026-02-06T00:49:13Z


5M elements, 
if all tetrahedra (coordination number 4),
worst case 20M vec3s, 
best case 5M * 4 / 4 = 5M vec3s

if I load them all into GPU memory and do an indirect draw call,
how much gpu mem does it use? 

elements: 5M * [4]u32 index = 80MB
points: 5M * [3]f32 * 4 / 4  = 60MB

140 MB, doable even on laptops

-- signed 2026-02-06T01:13:12Z


game plan:
- precompute rotated coords and sort by Z' axis
- precompute 1D AABB of all tets, referencing index of sorted coord 
- sort a min list and max list, ref sorted index
- on drag:
  - sweep through sorted coord list, find critical index
  - sweep through min list until value of index is at thresh
  - sweep through max list until value of index is at thresh
  - choose the shorter of the min/max list, worst case is 50% culled
  - allocate, loop through the chosen list and push intersecting tets, worst case is all are intersectiong
  - worst case: 2.5M u32 comparisons, say it's 10 cycles then at 1GHz it's 40fps -- might need further binning
  - now we get a list of triangles cut by the plane.


Deliverable Intermediates
step 1: (native) impl just culling, profile wall time, print to file
step 2: (native) add line list, profile wall time, print to file
step 3: rendering stuff

-- signed 2026-02-06T02:42:50Z


Bedtime. Coded a little bit after dinner for rough estimate of sorting 5M f32s and swap.

Unoptimized around 5 sec, optimized around 2 sec.

-- signed 2026-02-06T07:30:00Z

Memory swap might be the bottleneck compared to coord transform.
Need to benchmark sort vs transform on SoA vs AoS

also consider if matmul-then-insert is faster

...Ok matmul 5M elems is negligible

-- signed 2026-02-06T23:00:07Z


Checkpoint: raw matmul and sorting is acceptable. Leave it at naive impl and focus on culling now.

I have sorted list of points.

Assume list of tets.

keep arrs parallel so it's easy to memcpy whe building lists for in-place sort

Loop thorugh 5M tets:
  - given four vertices, record the indicies of the one with min and max Z
  - build unsorted aabb list (include the tet index for easy memcpy next)
    | tet | min | max |
    |-----|-----|-----|
    |  0  | 253 | 728 |
    |  1  | 129 | 417 |
    |  2  | 653 | 123 |
  - build sorted min list and max list
    | min | tet |     | max | tet |
    |-----|-----|     |-----|-----|
    | 102 | 233 |     | 301 | 623 |
    | 103 | 629 |     | 301 | 125 |
    | 103 | 192 |     | 302 | 920 |
    | 104 | 456 |     | 303 | 128 |
  - on sweep time:
    - binary search through sorted points list to find critical index
    - binary search where to cut the min and max list respectively
    - iterate over the shorter of the min/max list
      - naive: immediately start cuting the triangles, at most three faces cut
      - SIMD: build triangle soup, insert only if indices cross the critical index

-- signed 2026-02-07T00:56:06Z

|            |            |            |                  |                 |          |          |          |
|            |            |            |                  |                 |          |          |          |
| original x | original y | original z | rank of original | index of sorted | x sorted | y sorted | z sorted |
|            |            |            |                  |                 |          |          |          |
|            |            |            |                  |                 |          |          |          |


|             |                    |           |                    |           |                    |
|             |                    |           |                    |           |                    |
| v0 v1 v2 v3 |                    | tet index | rank of max vertex | tet index | rank of min vertex |
|             |                    |           |                    |           |                    |
|             |                    |           |                    |           |                    |


checkpoint, close to early bedtime

pay attent to fencepost error for tets generation

-- signed 2026-02-07T05:20:25Z


woke 1pm

use normal colors in frag shader, calc in vert shader

first test wireframe perf with SDL_Render

start thinking about parser

still need to actually generate triangle list, should use GL map

need to keep copy of unrotated coords

-- signed 2026-02-07T23:20:21Z


triangle list and lookup logic working. 

now need to calc the cuts

-- signed 2026-02-08T00:51:06Z


vertex table
||       |       |       ||       |       |       |          ||         |        |        |        ||
||       |       |       ||       |       |       |          ||         |        |        |        ||
|| src x | src y | src z || rot x | rot y | rot z | rot rank || sort id | sort x | sort y | sort z ||
||       |       |       ||       |       |       |          ||         |        |        |        ||
||       |       |       ||       |       |       |          ||         |        |        |        ||

tets table
||             |     |     ||             |          ||             |          ||
||             |     |     ||             |          ||             |          ||
|| v0 v1 v2 v3 | min | max || min_sort id | min_sort || max_sort id | max_sort ||
||             |     |     ||             |          ||             |          ||
||             |     |     ||             |          ||             |          ||

-- signed 2026-02-08T00:59:30Z


segment computation working.

all that remains is rendering and loading

-- signed 2026-02-08T07:40:43Z







starting challenge part 2

parser: start with @embedfile() instead of dealing with io

may rewrite parser in js if can't figure out wasm io


nodes sparse table
||   owner  | <T> + *data ||
||----------|-------------||
||          |             ||
|| u2 + u30 |  u1 + u31   ||
||          |             ||

node<non-parametric> dense table
||  x  |  y  |  z  ||
||-----|-----|-----||
||     |     |     ||
|| f32 | f32 | f32 ||
||     |     |     ||

elements sparse table
||   owner  | <T> | *data ||
||----------|-----|-------||
||          |     |       ||
|| u2 + u30 | u32 |  u32  ||
||          |     |       ||

elem<tet> dense table
|| v0 v1 v2 v3 ||
||-------------||
||             ||
||   [4]u32    ||
||             ||
(points to dense index, not sparse index)


No backlink index in dense tables since we're not modifying after load

Parse steps:
1. load nodes, write coord in dense and record location in sparse
2. load tets, lookup sparse node table for dense location then record in sparse elem table
